# R

## Assignment

For assigning a value to a variable, i use `<-` unless the variable is a parameter or an argument - then i use `=`:

```{r label = "assignment"}
variable <- "value"

name_of_function <- function(parameter = "value") {
  
}

```

## Debugging

### Printing out a value

```{r label = "print"}
print(2)

```

### Datatype

For figuring out the datatype [@zach_2021_how]:

```{r label = "datatype"}
class(2)

```

### Datatype and value

```{r label = "str"}
str(2)

```

### Is the value not set?

```{r label = "is-null"}
is.null(variable)

```

### Stopping execution

```{r label = "stop", eval = FALSE}
stop("error message")

```

## Numbers

### Converting a string to a number

```{r label = "as-numeric"}
number = "3"
str(number)

numeric_number <- as.numeric(number)
str(numeric_number)

```

### Sequencing

```{r label = "seq"}
seq(0, 14, 2)

```

### Rounding

#### Normal rounding

```{r label = "round"}
round(123.456, digits = 1)
round(122.5)
round(123.5)

```

#### Significant digits

For printing only significant digits, there's the function `signif` which takes two parameters: the initial number `x` and the number of significant digits `digits`:

```{r label = "signif"}
number <- 123.456

number_with_significant_digits <- signif(x = number, digits = 4)
print(number_with_significant_digits)

```

#### Prefixes

For formatting with prefixes, one can use the function *format_SI*[@format_si] from the package *BAAQMD/strtools*[@baaqmdstrtools]:

```{r label="format_SI"}
number <- c(1234.56, 0.123456)
librarian::shelf(c(
  "strtools"
))
format_SI(number)
format_SI(number, fixed=TRUE)
format_SI(number, engineering=TRUE)
format_SI(number, digits=2)

```

#### Powers and units

For using powers and units, there is the package *formatdown*[@layton_2023_formatdown]:

```{r label="formatdown"}
librarian::shelf(c(
  "formatdown"
))
numbers <- c(123.456, 2e-6, 5e8, 0.23)
format_power_numbers <- format_power(numbers)
format_power_numbers_digits <- format_power(numbers, digits = 2)
format_power_numbers_sci <- format_power(numbers, format="sci")
format_power_numbers_omit <- format_power(numbers, omit_power = c(-6, -6))
format_power_numbers_set <- format_power(numbers, set_power = 5)
units(numbers) <- "kg m-3"
format_units_numbers <- format_units(x=numbers, unit="g l-1")

```

`r format_power_numbers`

`r format_power_numbers_digits`

`r format_power_numbers_sci`

`r format_power_numbers_omit`

`r format_power_numbers_set`

`r format_units_numbers`

## Time

### Converting to time

```{r label = "as-date"}
string_of_time = "2020.7.08 16:43:59"
str(string_of_time)

librarian::shelf(c(
  "lubridate"
))

string_of_time_as_time <- parse_date_time(string_of_time, c("%Y.%m.%d %H:%M", "%m.%d.%Y %H:%M", "%Y.%m.%d %H:%M:%S"))
str(string_of_time_as_time)

```

[@lubridate].

### Parts of time

For *ms*, the package *lubridate* is needed. This function extracts the minutes and seconds.

```{r label = "ms"}
time <- "2:53"
parsed_time <- ms(time)
print(parsed_time)

```

The time in the last minute is $\qty{`r parsed_time`}{\s}$.

```{r label = "ms-as-numeric"}
s <- as.numeric(parsed_time)

```

The time is $\qty{`r s`}{\s}$.

## Array

### Creation

An array can be created using the function `c`:

```{r label = "array"}
array <- c("value_1", "value_2")
print(array)

```

### Referencing position

Referencing a position inside the array takes place using brackets whereas the first position has the index `1`:

```{r label = "array-referencing"}
value_at_position_2 <- array[2]
print(value_at_position_2)

array[2] <- "value_3"
print(array)

```

### Multidimensional

Arrays with the same length can be connected into `data.frame`:

```{r label = "data.frame"}
array_2 <- c("value_3", "value_4")
data_frame <- data.frame(array, array_2)
print(data_frame)

```

### Column names

A `data.frame` can have column names:

```{r label = "colnames"}
colnames(data_frame) <- c(
  "array",
  "array 2"
)

print(data_frame)

```

### Adding column[@zach_2021_how_to_use_cbind_in_R]

```{r label = "cbind"}
data_frame_with_array_2 <- cbind(data_frame, array_2)

print(data_frame_with_array_2)

```

### Row names

```{r label = "rownames"}
rownames(data_frame) <- c(
  "Caption of first row",
  "Caption of second row"
)

print(data_frame)

```

### Importing data

Data can be imported from a text file into a data frame:

```{r label = "read-table", eval = FALSE}
CO2_in_air <- read.table("co2_brw_surface-insitu_1_ccgg_DailyData.txt", header = TRUE, sep = "", dec = ".")

```

Data can also be imported from a comma-separated-values-(CSV-)file into a data frame:

```{r label = "import-washing-cycles"}
washing_cycles <- read.table("washing-cycles.csv", header = TRUE, sep = ",", dec = ".")

```

### Printing first rows

```{r label = "head"}
print(head(washing_cycles))

```

### Editing the look of a cell

```{r label = "cell-spec"}
librarian::shelf("kableExtra")
coloured_cell <- cell_spec(data_frame[, 2], color = "red")

```

[@cell_spec].

### Editing the content

```{r label = "mutate"}
librarian::shelf("dplyr")
mutate(data_frame, "array 2" = "mutated")

```

[@create].

### Size

```{r label = "length"}
length(data_frame)

nrow(data_frame)

```

### Looping

```{r label = "for"}

for (index in 1:length(data_frame)) {
  print(data_frame[index])
}

```

### Referencing by column name

```{r label = "bug"}
print(data_frame$`array 2`)

```

[@r_language].

\onecolumn

### Subsetting

As `washing_cycles` also contains records with missing data i want them removed:

```{r label = "subset"}

washing_cycles_with_full_records <- subset(washing_cycles, !is.na(`Veenäit.enne`) & "" != `Veenäit.pärast` & !is.na(`Veekulu..l.`) & !is.na(`kWh`))

print(head(washing_cycles_with_full_records))

```

[@subset].

This was how to remove incomplete records by manually setting the columns that contain empty records. There is a move convenient method to do that without specifying columns:

```{r label = "complete"}
washing_cycles_with_full_records <- washing_cycles[complete.cases(washing_cycles), ]

```

[@r_language].

I only want to see the data in the column `Kava`:

```{r label = "subset-column"}
program_in_washing_cycles <- subset(washing_cycles_with_full_records, select = `Kava`)

print(head(program_in_washing_cycles))

```

I only want to see cycles from the rows 2 to 4 in the second column:

```{r label = "subset-limited-cycles"}
print(washing_cycles_with_full_records[2:4, 2])

```

I want the last 216 rows to be removed:

```{r label = "subset-removing-rows"}
number_of_rows_in_washing_cycles_with_full_records <- nrow(washing_cycles_with_full_records)
data_frame_of_washing_cycles_with_full_records_without_last_records <- washing_cycles_with_full_records[
  -c((number_of_rows_in_washing_cycles_with_full_records - 215):number_of_rows_in_washing_cycles_with_full_records), ]
print(data_frame_of_washing_cycles_with_full_records_without_last_records)

```

I only want to see hot cycles:

```{r label = "subset-hot-cycles"}
hot_cycles <- subset(washing_cycles_with_full_records, `Temperatuur` > 40)
print(hot_cycles)

```

I only want to see the indices of the cycles at the temperature of $313.15 \times \mathrm{K}$:

```{r label = "subset-cycles-at-40"}
which(washing_cycles_with_full_records[3] == 40)

```

### Sorting

Displaying the indices of the descending sorted values of a vector:

```{r label = "sorting"}
librarian::shelf("dplyr")
desc(as.matrix(subset(head(washing_cycles_with_full_records), select = `Kava`)))

```

[@dplyr, p. 7, 21].

Sorting values in ascending order according to the program:

```{r label = "arrange"}
head(arrange(washing_cycles_with_full_records, `Kava`))

```

### Totals

```{r label = "adorn-totals"}
librarian::shelf("janitor")
adorn_totals(dat = head(subset(x = washing_cycles_with_full_records, select = c(`Algus`, `Veekulu..l.`))), where = "row", fill = "", na.rm = TRUE, name = "Kokku", c(`Veekulu..l.`))

```

[@adorn_totals].

\twocolumn

### Mean

Mean row-wise can be calculated using `rowMeans()`[@zach_2021_how_to_use_rowMeans_function_in_R].

```{r label = "rowMeans"}
t_1 <- c(7.508, 4.452, 3.434, 2.978, 2.752)
t_2 <- c(7.775, 4.515, 3.434, 2.978, 2.752)
t_3 <- c(7.685, 4.47, 3.603, 2.992, 2.732)

data_frame_of_mass_time <- data.frame(
  t_1,
  t_2,
  t_3
)

rowMeans(x = data_frame_of_mass_time[, c(1:3)])

```

## Functions

Functions can be made using the keyword `function`:

```{r label = "function"}
add <- function(first, second, digits = 2) {
  return(signif(first + second, digits = digits))
}

add(first = 123, second = 456) # using the default value 2 for digits

sum <- add(first = 123, second = 456, digits = 1)

```

It is not possible to assign an argument with the same name as the parameter[@promise]. In the example above, the value for `first` could not be `first` although there might be an external variable `first`, id est `first = first` is not allowed. I have to use different names.

## Square root

A square root can be calculated using the function `sqrt()`:

```{r label = "sqrt"}
input_for_square_root <- 4
square_root <- sqrt(input_for_square_root)

```

The square root of $\num{`r as.character(input_for_square_root)`}$ is $\num{`r as.character(square_root)`}$.

## Derivation

```{r label = "derivative"}
initial_function <- "x^3 + x^2"
functionToUse <- parse(text = initial_function)

librarian::shelf(c(
  "Ryacas"
))

derivative = D(functionToUse, "x")
string_of_derivative <- deparse(derivative)

```

The derivative of $`r initial_function`$ is $`r string_of_derivative`$.

```{r label = "critical-places"}
equality <- paste(string_of_derivative, "== 0")
print(equality)
print(paste("Solve(", equality, ", x)", sep = ""))
print(y_rmvars(paste("Solve(", equality, ", x)", sep = "")))
critical_places <- yac_str(y_rmvars(paste("Solve(", equality, ", x)", sep = "")))
print(critical_places)
critical_places_as_r <- as_r(critical_places)
print(critical_places_as_r)
critical_solution_1 <- (critical_places_as_r[1])
critical_solution_2 <- critical_places_as_r[2]

```

The critical solutions of $`r initial_function`$ are `r critical_solution_1` and `r critical_solution_2`.

## Comments

Comments can be done with `#`:

```{r label = "comment"}
print(sum) # printing out the value of sum

```

## Strings

Strings can be written using either apostrophes or quotation marks.

[]{#gsub}

For substituting something inside a string, `gsub` can be used [@r]:

```{r label = "gsub"}
gsub("_", "\\_", array, fixed = TRUE)

```

Here, in order to preserve a backslash, it has to be escaped as otherwise, it escapes the underscore. If I would turn off `fixed`, the function would work like with regular expressions.

## Branching

```{r label = "ifelse"}
ifelse(is.na(NA), "Not Available", "Available")

```

\onecolumn

## Table

### A user-friendly look

A table that is not just in R code but designed and all can be created using `kable` and `kableExtra`[@kableextra]. I have built a wrapper function `print_table` for that purpose so that I do not have to rewrite some general things from table to table. An example table is \@ref(tab:table) on the page `r render_pageref(reference = "tab:table")`.

```{r label = "table"}
omega <- c(932.0058, 827.2861, 733.0383, 628.3185, 523.5988, 418.8790, 314.1593)
omega_P <- c(0.03966657, 0.04155546, 0.05073632, 0.05411874, 0.05817764, 0.03878509, 0.01811760)

data_frame_of_precession <- data.frame(
  omega,
  omega_P
)

colnames(data_frame_of_precession) <- c(
  "$\\frac{\\omega}{\\unit{\\per\\s}}$",
  "$\\frac{\\omega_\\text{P}}{\\unit{\\per\\s}}$"
)

print_table(
  table = data_frame_of_precession,
  caption = "Pretsessiooni nurkkiiruse sõltuvus güroskoobi nurkkiirusest."
)

```

### Untolerated symbols

I have to pay attention that there can't be any underscores inside the table unless they are part of an equation. They can be escaped using [`gsub`](#gsub) and the result is shown as the table \@ref(tab:table-with-escaped-underscores) on the page `r render_pageref(reference = "tab:table-with-escaped-underscores")`.

```{r label = "table-with-escaped-underscores"}
print_table(
  table = sapply(data_frame, function(value) gsub("_", "\\_", value, fixed = TRUE)),
  caption = "Caption."
)

```

Inside the table, backslashes must be escaped.

### Number of digits after comma

Tables \@ref(tab:table-with-digits-default) on the page `r render_pageref(reference = "tab:table-with-digits-default")` and \@ref(tab:table-with-digits-nondefault) on the page `r render_pageref(reference = "tab:table-with-digits-nondefault")` are for comparing the number of digits after comma. The table \@ref(tab:table-with-digits-default) has the default number of digits and the table \@ref(tab:table-with-digits-nondefault) has another number of digits in every number after comma.

```{r label = "table-with-digits-default"}
water_report <- head(subset(x = washing_cycles_with_full_records, select = c(`Algus`, `Veenäit.enne`, `Veenäit.pärast`)))

librarian::shelf(c(
  'dplyr'
))

water_report <- water_report %>%
  mutate(`Veenäit.pärast` = as.numeric(`Veenäit.pärast`))

colnames(water_report) <- c(
  "Start",
  "$\\mathrm{\\frac{\\text{Used water before}}{\\mathrm{m^3}}}$",
  "$\\mathrm{\\frac{\\text{Used water after}}{\\mathrm{m^3}}}$"
)

print_table(
  table = water_report,
  caption = "Water report with numbers with up to two digits after comma."
)

```

[@dplyr, p. 38 to 42].

```{r label = "table-with-digits-nondefault"}
print_table(
  table = water_report,
  caption = "Water report with numbers with up to four digits after comma.",
  digits = 4
)

```

### Additional header

It's also possible for the table to have an additional header whose columns span over multiple columns in the first header [@add_header_above] (the table \@ref(tab:table-with-additional-header) on the page `r render_pageref(reference = "tab:table-with-additional-header")`):

```{r label = "table-with-additional-header"}
print_table(
  table = water_report,
  caption = "Water report with additional header.",
  additional_header = c("Spanned header" = 4)
)

```

### Look

It's possible to change the look of a row (the table \@ref(tab:table-with-row-specification) on the page `r render_pageref(reference = "tab:table-with-row-specification")`):

```{r label = "table-with-row-specification"}
print_table(
  table = water_report,
  caption = "Water report with coloured row."
) %>%
  row_spec(2, color = "teal")

```

Here, `%>%` means piping.

And it's possible to change the look of a column (the table \@ref(tab:table-with-column-specification) on the page `r render_pageref(reference = "tab:table-with-column-specification")`):

```{r label = "table-with-column-specification"}
print_table(
  table = water_report,
  caption = "Water report with wider column."
) %>%
  column_spec(1, width = "16em")

```

### Landscape

If the table is too wide to fit the portrait format, it can be displayed in the landscape mode (the table \@ref(tab:table-with-landscape) on the page `r render_pageref(reference = "tab:table-with-landscape")`):

```{r label = "table-with-landscape"}
print_table(
  table = water_report,
  caption = "Water report as landscape."
) %>%
  landscape()

```

### Footnotes

Linked footnotes don't work with `kable`. Footnotes can be created like this (the table \@ref(tab:footnotes) on the page `r render_pageref(reference = "tab:footnotes")`):

```{r label = "footnotes"}

DATA_FRAME_OF_COMPARISON <- data.frame(
  0.3
)

colnames(DATA_FRAME_OF_COMPARISON) <- c(
  paste("$\\frac{T_\\text{dew}}{}$", footnote_marker_number(1))
)

print_table(
  table = DATA_FRAME_OF_COMPARISON,
  caption = "Water report with a footnote.",
  footnotes = c(
    "juhendi tabel 5.1" # 1
  )
)

```

`threeparttable` must be set to `TRUE` for just in case the footnote is too long for the width of the paper [@footnote].

### Transposing

By default, I feed one-dimensional arrays to data frame and the values of these arrays will be displayed from top to down. If I want them to be displayed from left to right, I have to transform the table (the table \@ref(tab:t) on the page `r render_pageref(reference = "tab:t")`):

```{r label = "t"}

DATA_FRAME_OF_COMPARISON <- data.frame(
  0.3
)

rownames(DATA_FRAME_OF_COMPARISON) <- c(
  "\"Pasco\" ilmajaam"
)

colnames(DATA_FRAME_OF_COMPARISON) <- c(
  paste("$\\frac{T_\\text{dew}}{}$", footnote_marker_number(1))
)

print_table(
  DATA_FRAME_OF_COMPARISON,
  caption = "Table with rows and columns exchanged.",
  do_i_transpose = TRUE
)

```

### Coloring according to values

It is possible to automatically show the values growing by different colors using the function `spec_color` of `kableExtra` as seen in the table \@ref(tab:spec-color) leheküljel `r render_pageref(reference="tab:spec-color")`.

(ref:solubility) Kilogrammi ühendi lahustuvus vees kilogrammi vee kohta[@haynes_2014_crc, lk 4-43-4-114]. If the value of the solubility is unknown then the solubility is marked as follows: slightly soluble: \qty{1}{\kg\per\kg}, soluble: \qty{0.1}{\kg\per\kg}, very soluble: \qty{0.01}{\kg\per\kg}.

```{r label="spec-color"}
Li <- c(
  4.5e-1, # acetate
  1.81, # bromide
  1.30e-2 # carbonate
)

Na <- c(
  5.04e-1, # acetate
  9.46e-1, # bromide
  3.07e-2 # carbonate
)

K <- c(
  2.69, # acetate
  6.78e-1, # bromide
  1.11 # carbonate
)

solubility <- data.frame(
  Li,
  Na,
  K
)

colnames(solubility) <- c(
  "\\ce{Li+}",
  "\\ce{Na+}",
  "\\ce{K+}"
)
rownames(solubility) <- c(
  "\\ce{[CH3CO2]-}",
  "\\ce{Br-}",
  "\\ce{[CO3]^2-}"
)
librarian::shelf(c(
  "dplyr"
))
solubility <- mutate_all(.tbl=solubility, ~cell_spec(.x, color=spec_color(.x), font_size = spec_font_size(.x)))
print_table(table=solubility, caption="(ref:solubility)")

```

\newpage

### Line breaks

The example (@linebreak) shows how to deal with line breaks inside a table[@best].

(@linebreak)

  \begin{lstlisting}[label=lst:listings-table-linebreak, language=R, caption=An example of how to have line breaks inside a table.]

  intro_redox_reactions_25<- data.frame(
    linebreak(c(
      "\\blank{ränitetrakloriid}",
      "\\blank{tinaoksiid}",
      "\\blank{vanaadiumpentoksiid}",
      "\\blank{booroksiid}"
    ))
  )

  rownames(intro_redox_reactions_25) <- linebreak(c(
    "\\blank{1}\\textbf{\\ce{Si\\textsuperscript{\\blank{4+}}}\\ce{Cl4(l)} +}\\blank{2} \\ce{H2(g)}\n \\ce{ ->}\\blank{1}\\ce{ Si(s) +}\\blank{2}\\ce{ HCl(g)}",
    "\\blank{1}\\textbf{\\ce{Sn\\textsuperscript{\\blank{4+}}}\\ce{O2(s)} +}\\blank{1}\\ce{ C(s)}\n \\ce{ ->[\\qty{1,2e3}{\\degreeCelsius}]}\\blank{1}\\ce{ Sn(l) +}\\blank{1}\\ce{ CO2}",
    "\\blank{1}\\textbf{\\ce{V2\\textsuperscript{\\blank{5+}}}\\ce{O5 (s)} +}\\blank{5}\\ce{ Ca (l)}\n \\ce{->[\\Delta]}\\blank{2}\\ce{ V (s) +}\\blank{5}\\ce{ CaO (s)}",
    "\\blank{1}\\textbf{\\ce{B2\\textsuperscript{\\blank{3+}}}\\ce{O3(s)} +}\\blank{3}\\ce{ Mg(s)}\n \\ce{ ->}\\blank{2}\\ce{ B(s) +}\\blank{3}\\ce{ MgO(s)}"
  ))

  colnames(intro_redox_reactions_25) <- c(
    "Nimetus"
  )
  
  print_table(table = intro_redox_reactions_25, caption = "Oksüdatsiooniastme määramine ja võrrandi kujundamine.")

  \end{lstlisting}

\begin{landscape}

\begin{center}\faHandPointDown\end{center}

```{r label="intro-redox-reactions-25", echo=FALSE}
intro_redox_reactions_25<- data.frame(
  linebreak(c(
    "\\blank{ränitetrakloriid}",
    "\\blank{tinaoksiid}",
    "\\blank{vanaadiumpentoksiid}",
    "\\blank{booroksiid}"
  ))
)

rownames(intro_redox_reactions_25) <- linebreak(c(
  "\\blank{1}\\textbf{\\ce{Si\\textsuperscript{\\blank{4+}}}\\ce{Cl4(l)} +}\\blank{2} \\ce{H2(g)}\n \\ce{ ->}\\blank{1}\\ce{ Si(s) +}\\blank{2}\\ce{ HCl(g)}",
  "\\blank{1}\\textbf{\\ce{Sn\\textsuperscript{\\blank{4+}}}\\ce{O2(s)} +}\\blank{1}\\ce{ C(s)}\n \\ce{ ->[\\qty{1,2e3}{\\degreeCelsius}]}\\blank{1}\\ce{ Sn(l) +}\\blank{1}\\ce{ CO2}",
  "\\blank{1}\\textbf{\\ce{V2\\textsuperscript{\\blank{5+}}}\\ce{O5 (s)} +}\\blank{5}\\ce{ Ca (l)}\n \\ce{->[\\Delta]}\\blank{2}\\ce{ V (s) +}\\blank{5}\\ce{ CaO (s)}",
  "\\blank{1}\\textbf{\\ce{B2\\textsuperscript{\\blank{3+}}}\\ce{O3(s)} +}\\blank{3}\\ce{ Mg(s)}\n \\ce{ ->}\\blank{2}\\ce{ B(s) +}\\blank{3}\\ce{ MgO(s)}"
))

colnames(intro_redox_reactions_25) <- c(
  "Nimetus"
)

print_table(table = intro_redox_reactions_25, caption = "Oksüdatsiooniastme määramine ja võrrandi kujundamine.")

```

\end{landscape}

## Exponents and logarithms

$$e^1$$

```{r label = "e"}
exp(1)

```

$$\mathrm{ln}(e)$$

```{r label = "log"}
log(exp(1))

```

\onecolumn

## Plotting

### One graph

An example of plotting data is putting data points to the plot - visible on the figure \@ref(fig:ggplot) on the page `r render_pageref(reference = "fig:ggplot")`. The packages:

`ggplot2`
: for plotting [@ggplot2]

`latex2exp`
: for using `r render_nonmath_LaTeX_string_universal("\\LaTeX")` strings in labels

The parameters:

`data`
: the data table

`aes`
: the function that describes axis

`x`
: data array for *x* axis

`y`
: data array for *y* axis

`geom_point`
: the function for plotting data points

`shape`
: the shape of points

`size`
: the size of points

`color`
: the border color

`fill`
: the fill color

`labs`
: the function for creating labels for axis

`TeX`
: the function for converting `r render_nonmath_LaTeX_string_universal("\\LaTeX")` strings in labels

```{r label = "ggplot", fig.cap="Washing cycles.", dev='cairo_pdf'}

librarian::shelf(c(
  "Cairo",
  "ggplot2",
  "latex2exp"
))

ggplot(data = washing_cycles_with_full_records, aes(x = `Temperatuur`, y = `Pöördeid.min`)) + geom_point(shape = 23, color = "#008000", fill = "#ff6600", size = 3) +
  labs(x = TeX("$\\frac{\\textit{t}}{^\\circ C}$"), y = TeX("$\\frac{\\textit{f}}{min}$"))

```

In order to use Unicode characters like the degree symbol, we need the library `Cairo` and the corresponding `dev`[@a2018_ggplot].

\pagebreak

### Additional data point

A single additional data point can be added using `geom_point` (figure \@ref(fig:ggplot-additional-data-point) on the page `r render_pageref(reference = "fig:ggplot-additional-data-point")`)[@adding].

```{r label="ggplot-additional-data-point", fig.cap="Additional data point.", dev='cairo_pdf'}

librarian::shelf(c(
  "Cairo",
  "ggplot2",
  "latex2exp"
))

ggplot(data = washing_cycles_with_full_records, aes(x = `Temperatuur`, y = `Pöördeid.min`)) +
  geom_point(shape = 23, color = "#008000", fill = "#ff6600", size = 3) +
  geom_point(aes(x = 75, y = 900), shape = 23, size = 3) +
  labs(x = TeX("$\\frac{\\textit{t}}{^\\circ C}$"), y = TeX("$\\frac{\\textit{f}}{min}$"))
```

### Multiple graphs

Multiple graphs can be displayed on a same figure as seen on the figure \@ref(fig:ggplot-multiple-graphs) on the page `r render_pageref(reference = "fig:ggplot-multiple-graphs")`.

```{r label = "ggplot-multiple-graphs", fig.cap=paste("Water and electricity consumption between", min_time, "and", max_time, ".")}
librarian::shelf(c(
  "lubridate"
))

washing_cycles_with_full_records <- washing_cycles_with_full_records %>%
  mutate(`Algus` = parse_date_time(x = washing_cycles_with_full_records$Algus, orders = c(
  "%Y-%m-%d %H",
  "%Y.%m.%d %H:%M",
  "%Y.%m.%d %H:%M:%S",
  "%m.%d.%Y %H:%M",
  "%m.%d.%Y %H:%M:%S"
))) %>%
   mutate(`veekulu_dal` = (as.numeric(washing_cycles_with_full_records$Veenäit.pärast) - washing_cycles_with_full_records$Veenäit.enne) * 100)

min_time = min(washing_cycles_with_full_records$Algus)
max_time = max(washing_cycles_with_full_records$Algus)

librarian::shelf(c(
  "ggplot2",
  "latex2exp"
))

ggplot(data = washing_cycles_with_full_records, mapping = aes(x = `Algus`, y = `veekulu_dal`)) +
  geom_point(shape = 23, color = "#008000", fill = "#008000", size = 3) +
  labs(x = "Algus", y = TeX("$\\frac{\\textit{V} \\times 10^2}{m^3}$")) +
  geom_point(mapping = aes(x = `Algus`, y = `kWh`), color = "#ff6600", fill = "#ff6600", shape = 24, size = 3)  +
  scale_y_continuous(sec.axis = sec_axis(~., name = TeX("\\frac{\\textit{W}}{kWh}"))) +
  theme(
    axis.title.y = element_text(colour = "#008000"),
    axis.text.y = element_text(colour = "#008000"),
    axis.ticks.y = element_line(colour = "#008000"),
    axis.title.y.right = element_text(colour = "#ff6600"),
    axis.ticks.y.right = element_line(colour = "#ff6600"),
    axis.text.y.right = element_text(colour = "#ff6600")
  )

```

### Trend line

On the figure \@ref(fig:geom-smooth) on the page `r render_pageref(reference = "fig:geom-smooth")`.

```{r label = "geom-smooth", fig.cap="Graph with a trend line."}
ggplot(data = washing_cycles_with_full_records, aes(x = `Temperatuur`, y = `Pöördeid.min`)) + geom_point(shape = 23, color = "#008000", fill = "#ff6600", size = 3) +
  labs(x = TeX("$\\frac{\\textit{t}}{\\degree C}$"), y = TeX("$\\frac{\\textit{f}}{min}$")) +
  geom_smooth()

```

### Regression and correlation

The figure \@ref(fig:stat-regline-cor) on the page `r render_pageref(reference = "fig:stat-regline-cor")` represents the correlation between the water and electricity consumption between `r min_time` and `r max_time`. The plot displays the smooth regression line[@stat_poly_line] and the correlation coefficient. There are also the data about the regression. Both labels have been positioned vertically.

For `ggpubr`, the dependency `nloptr` must be installed directly in *Ubuntu*[@unable]:

```{bash label = "nloptr", eval = FALSE}
sudo apt-get install libnlopt-dev

```

```{r label = "stat-regline-cor", fig.cap=paste("Correlation between the water and electricity consumption between", min_time, "and", max_time, ".")}
librarian::shelf(c(
  "ggplot2",
  "ggpmisc", #for stat_poly_line
  "ggpubr", # for stat_regline_equation
  "latex2exp"
))

if (!decimal_separator_period) { # for stat_regline_equation and stat_cor
  options(OutDec = ".")
}
ggplot(data = washing_cycles_with_full_records, mapping = aes(x = `Veekulu..l.`, y = `kWh`)) +
  geom_point(shape = 23, color = "#ff6600", fill = "#ff6600", size = 3) +
  labs(x = TeX("$\\frac{\\textit{V}}{m^3}$"), y = TeX("$\\frac{\\textit{W}}{kWh}$")) +
  stat_poly_line() +
  stat_regline_equation(mapping = aes(x = `Veekulu..l.`, y = `kWh`, label = paste(after_stat(eq.label), after_stat(rr.label), after_stat(adj.rr.label), sep = "~~~~")), color = "#ff6600", label.y = 3) +
  stat_cor(aes(x = `Veekulu..l.`, y = `kWh`), color = "#ff6600", label.y = 2.5)
if (!decimal_separator_period) {
  options(OutDec = ",")
}

```

It is possible to use different kind of trend lines as seen on the figure \@ref(fig:stat-poly-line) on the page `r render_pageref(reference = "fig:stat-poly-line")`:

```{r label = "stat-poly-line", fig.cap="Polynomial trend line with the degree \\num{2}."}
omega <- c(932.0058, 827.2861, 733.0383, 628.3185, 523.5988)
h <- c(303.44868, 239.08893, 187.71603, 137.91380,  95.77349)

data_frame_of_precession_with_height_without_outliers <- data.frame(
  omega,
  h
)

color_of_height <- "#ff00ff"
color_x <- "#008000"

ggplot(
  data <- data_frame_of_precession_with_height_without_outliers,
  mapping <- aes(x = omega, y = h)
) +
  geom_point(shape = 23, size = 1) +
  labs(x = TeX("$\\frac{\\omega}{\\frac{1}{s}}$"), y = TeX("$\\frac{h}{m}$")) +
  theme(
    axis.title.x = element_text(colour = color_x),
    axis.text.x = element_text(colour = color_x),
    axis.ticks.x = element_line(colour = color_x),
    axis.title.y = element_text(colour = color_of_height),
    axis.text.y = element_text(colour = color_of_height),
    axis.ticks.y = element_line(colour = color_of_height)
  ) +
  stat_poly_line(formula = y ~ poly(x, 2))

```

### Error bars

The figure \@ref(fig:ggplot-errorbar) on the page `r render_pageref(reference = "fig:ggplot-errorbar")` represents the water and electricity consumption between `r min_time` and `r max_time` with errorbars.

```{r label = "ggplot-errorbar", fig.cap=paste("Water and electricity consumption between", min_time, "and", max_time, " with errobars.")}

librarian::shelf(c(
  "ggplot2",
  "latex2exp"
))

margin_of_V <- 1e-3 / 2 * 2 * 1e2
margin_of_W <- .1 / 2

color_x <- "#008000"
color_y <- "#ff6600"

ggplot(data = washing_cycles_with_full_records, mapping = aes(x = `veekulu_dal`, y = `kWh`)) +
  geom_point(shape = 23, size = 1) +
  labs(x = TeX("$\\frac{\\textit{V} \\times 10^2}{m^3}$"), y = TeX("$\\frac{\\textit{W}}{kWh}$")) +
  geom_errorbarh(aes(xmin = `veekulu_dal` - margin_of_V, xmax = `veekulu_dal` + margin_of_V, y = `kWh`), color = color_x) +
  geom_errorbar(aes(x = `veekulu_dal`, ymin = `kWh` - margin_of_W, ymax = `kWh` + margin_of_W), color = color_y) +
  theme(axis.title.x = element_text(colour = color_x), axis.text.x = element_text(colour = color_x), axis.ticks.x = element_line(colour = color_x), axis.title.y = element_text(colour = color_y), axis.text.y = element_text(colour = color_y), axis.ticks.y = element_line(colour = color_y))

```

Joonisel \@ref(fig:illuminance-uncertainties) leheküljel `r render_pageref(reference = "fig:illuminance-uncertainties")` on esitatud valgustugevuse mõõtmise tulemused keskväärtuse ja mõõtemääramatustega: mustaga on tähistatud A-, oranžiga B1-, roosaga B2-tüüpi ja rohelisega kogu mõõtemääramatus[@horizontal]. Sellelt jooniselt näeme, kui palju mingit tüüpi mõõtemääramatus antud juhul mõju avaldab.

```{r label = "illuminance-uncertainties", fig.cap="Valgustugevus koos keskmise valgustugevuse ja mõõtemääramatustega."}
librarian::shelf(c(
  "ggplot2",
  "latex2exp"
))
color_x <- "#008000"
illuminance <- c(923, 905, 593, 587)
illuminance_data_frame = data.frame(illuminance)
illuminance_mean <- mean(illuminance)
illuminance_se <- as.numeric(mean_se(illuminance)["ymax"] - illuminance_mean) 
illuminance_size <- length(illuminance)
illuminance_size_less_1 <- illuminance_size - 1
librarian::shelf(c(
  "distributions3"
))
studentTDistribution = StudentsT(df = illuminance_size_less_1)
alpha <- 0.05
probability_for_Student <- 1 - alpha / 2
caliper_number_student = quantile(studentTDistribution, probability_for_Student)
illuminance_uncertainty_A <- caliper_number_student * illuminance_se

precision_ratio <- .05
number_of_least_sigfig = 10
student_inf <- quantile(StudentsT(df = Inf), probability_for_Student)
illuminance_uncertainty_B_1 <- student_inf * (illuminance_mean * precision_ratio + number_of_least_sigfig) / 3

illuminance_smallest_unit <- 1
probability <- 1 - alpha

illuminance_uncertainty_B_2 <- probability * illuminance_smallest_unit / 2

illuminance_uncertainty <- sqrt(illuminance_uncertainty_A^2 + illuminance_uncertainty_B_1^2 + illuminance_uncertainty_B_2^2)

ggplot(data = illuminance_data_frame, mapping = aes(x = `illuminance`, y = 0)) +
  geom_point(shape = 23, size = 1) +
  geom_point(aes(x = illuminance_mean, y = 0), shape = 23, size = 2, color = color_x) +
  labs(x = TeX("$\\frac{\\textit{q}}{lx}$")) +
  geom_errorbarh(aes(xmin = illuminance_mean - illuminance_uncertainty, xmax = illuminance_mean + illuminance_uncertainty), color = color_x) +
  geom_errorbarh(aes(xmin = illuminance_mean - illuminance_uncertainty_A, xmax = illuminance_mean + illuminance_uncertainty_A), height = .1) +
  geom_errorbarh(aes(xmin = illuminance_mean - illuminance_uncertainty_B_1, xmax = illuminance_mean + illuminance_uncertainty_B_1), color = "#ff6600", height = .2) +
  geom_errorbarh(aes(xmin = illuminance_mean - illuminance_uncertainty_B_2, xmax = illuminance_mean + illuminance_uncertainty_B_2), color = "#ff66ff", height = .4) +
  theme(
    axis.title.x = element_text(colour = color_x),
    axis.text.x = element_text(colour = color_x),
    axis.ticks.x = element_line(colour = color_x),
    axis.title.y=element_blank(), 
    axis.text.y=element_blank(), 
    axis.ticks.y=element_blank()
  )

```

### Accuracy

Joonisel \@ref(fig:ruler-uncertainties-without-accuracy) leheküljel `r render_pageref(reference = "fig:ruler-uncertainties-without-accuracy")` on esitatud mõõdetud keskväärtus koos mõõtemääramatusega graafiliselt.

```{r label = "ruler-uncertainties-without-accuracy", fig.cap="Kahe kontrollpunkti omavaheline kaugus mõõtemääramatusega."}
librarian::shelf(c(
  "ggplot2",
  "latex2exp"
))

color_x <- "#008000"
ruler_smallest_unit <- .5
ruler_relation = 4000 / 400
ruler_smallest_unit_actual <- ruler_smallest_unit * ruler_relation 
ruler_x <- 42
ruler_x_actual <- ruler_x * ruler_relation
ruler_data_frame <- data.frame(ruler_x_actual)

plot <- ggplot(data = ruler_data_frame, mapping = aes(x = `ruler_x_actual`, y = 0)) +
  geom_point(shape = 23, size = 1) +
  labs(x = TeX("$\\frac{\\textit{q}}{m}$")) +
  geom_errorbarh(aes(xmin = `ruler_x_actual` - ruler_smallest_unit_actual, xmax = `ruler_x_actual` + ruler_smallest_unit_actual), color = color_x) +
  theme(
    axis.title.x = element_text(colour = color_x),
    axis.text.x = element_text(colour = color_x),
    axis.ticks.x = element_line(colour = color_x),
    axis.title.y=element_blank(), 
    axis.text.y=element_blank(), 
    axis.ticks.y=element_blank()
  )

plot

```

The figure \@ref(fig:ruler-uncertainties-with-accuracy) on the page `r render_pageref(reference="fig:ruler-uncertainties-with-accuracy")` shows how to specify the accuracy of the numbers on axis[@how].

```{r label = "ruler-uncertainties-with-accuracy", fig.cap="With specified accuracy."}
plot +
  scale_x_continuous(
    labels = scales::label_number(accuracy = 1)
  )

```

## Regression model[@lm]

```{r label = "lm"}
angular_acceleration <- c(5.902952, 17.246897, 28.401369, 38.892302, 45.907424)
torque <- c(0.001153365, 0.002174215, 0.003190228, 0.004201956, 0.005009516)
formula = torque ~ angular_acceleration
model = lm(formula = formula)

b <- model$coefficients[1]
k <- model$coefficients[2]

```

```{verbatim label = "result-of-lm", language = "markdown"}
Regressioonisirge tõus on \qty{`r as.character(signif(x = k, digits = 3))`}{\kg\m\squared} ja see näitab inertsimomenti. Vabaliige on \qty{`r as.character(signif(x = b, digits = 3))`}{\N\m} ja see näitab hõõrdejõu momenti.

```

Regressioonisirge tõus on \qty{`r as.character(signif(x = k, digits = 3))`}{\kg\m\squared} ja see näitab inertsimomenti. Vabaliige on \qty{`r as.character(signif(x = b, digits = 3))`}{\N\m} ja see näitab hõõrdejõu momenti.

## Correlation

In order to get the values of the result of a correlation analysis, one can use `cor`[@zach_2022_how_to_use_cor_to_calculate_correlation_coefficients_in_R].

```{r label = "cor"}
cor(
  washing_cycles_with_full_records$`Veekulu..l.`,
  washing_cycles_with_full_records$`kWh`,
  method = 'pearson'
)

```

## Linearizing

Lasen joonestada pretsessiooninurkkiiruse sõltuvuse graafiku rootori osakeste nurkkiirusest (joonis \@ref(fig:angular-speed) leheküljel `r render_pageref(reference = "fig:angular-speed")`).

```{r label = "angular-speed", fig.cap = "Pretsessiooninurkkiiruse sõltuvus rootori osakeste nurkkiirusest."}
librarian::shelf(c(
  "ggplot2",
  "latex2exp"
))

color_x <- "#008000"
color_y <- "#ff6600"                                                                                                                         

number_of_rows_in_data_frame_of_precession <- nrow(data_frame_of_precession)
data_frame_of_precession_without_outliers <- data_frame_of_precession[-c((number_of_rows_in_data_frame_of_precession - 1):number_of_rows_in_data_frame_of_precession), ]

ggplot(
  data <- data_frame_of_precession_without_outliers,
  mapping <- aes(x = `$\\frac{\\omega}{\\unit{\\per\\s}}$`, y = `$\\frac{\\omega_\\text{P}}{\\unit{\\per\\s}}$`)
) +
  geom_point(shape = 23, size = 1) +
  labs(x = TeX("$\\frac{\\omega}{\\frac{1}{s}}$"), y = TeX("$\\frac{\\omega_P}{\\frac{1}{s}}$")) +
  theme(
    axis.title.x = element_text(colour = color_x),
    axis.text.x = element_text(colour = color_x),
    axis.ticks.x = element_line(colour = color_x),
    axis.title.y = element_text(colour = color_y),
    axis.text.y = element_text(colour = color_y),
    axis.ticks.y = element_line(colour = color_y)
  )

```

Teooria seosega \@ref(eq:angular-velocity-of-precession-by-angular-moment) leheküljel `r render_pageref(reference = "eq:angular-velocity-of-precession-by-angular-moment")` ennustab pöördvõrdelist sõltuvust.

\begin{align}
\omega_\text{P} = \frac{((\overrightarrow{r_\text{balancer; final}} - \overrightarrow{r_\text{balancer; initial}}))  \times \overrightarrow{F_\text{balancer}}}{I \cdot \vec{\omega}}.
(\#eq:angular-velocity-of-precession-by-angular-moment)
\end{align}

Joonisel \@ref(fig:angular-speed) leheküljel `r render_pageref(reference = "fig:angular-speed")` olev graafik lineariseeritud kujul[@a2019_how] on esitatud joonisel \@ref(fig:linearized-angular-speed) leheküljel `r render_pageref(reference = "fig:linearized-angular-speed")`.

```{r label = "linearized-angular-speed", fig.cap="Lineariseeritud nurkkiiruste graafik. Propelleri nurkkiiruse asemel on esitatud selle pöördväärtus, mis näitab, mitu sekundit ühe radiaani läbimine kestis."}
data_frame_of_precession_without_outliers_linearized <- mutate(.data = data_frame_of_precession_without_outliers, linearized_omega = 1 / `$\\frac{\\omega}{\\unit{\\per\\s}}$`, .keep = "unused", .after = `$\\frac{\\omega}{\\unit{\\per\\s}}$`)
colnames(data_frame_of_precession_without_outliers_linearized) <- c(
  "$\\frac{\\frac{1}{\\omega}}{\\unit{\\s}}$",
  "$\\frac{\\omega_\\text{P}}{\\unit{\\per\\s}}$"
)

ggplot(
  data <- data_frame_of_precession_without_outliers_linearized,
  mapping <- aes(x = `$\\frac{\\frac{1}{\\omega}}{\\unit{\\s}}$`, y = `$\\frac{\\omega_\\text{P}}{\\unit{\\per\\s}}$`)
) +
  geom_point(shape = 23, size = 1) +
  labs(x = TeX("$\\frac{\\frac{1}{\\omega}}{s}$"), y = TeX("$\\frac{\\omega_P}{\\frac{1}{s}}$")) +
  theme(
    axis.title.x = element_text(colour = color_x),
    axis.text.x = element_text(colour = color_x),
    axis.ticks.x = element_line(colour = color_x),
    axis.title.y = element_text(colour = color_y),
    axis.text.y = element_text(colour = color_y),
    axis.ticks.y = element_line(colour = color_y)
  )

```

\twocolumn

## Embedding

Including works for web output[@riederer_93]:

```{verbatim label = "example-of-hardware"}
if (knitr::is_html_output()) {
  knitr::include_url("https://learningapps.org/view409713")
}

```

```{r label = "hardware", echo=FALSE}
if (knitr::is_html_output()) {
  knitr::include_url("https://learningapps.org/view409713")
}

```

\onecolumn

## Figures

### Displaying a figure

For figures, i created a wrapper function `include_external_graphics()` for `knitr`'s `include_graphics()` because natively, `include_graphics()` doesn't support all the necessary file types: 

````{verbatim label = "including-external-graphics"}
```{r label = "<label of figure>", echo=FALSE, fig.cap = "<caption of figure>"}
include_external_graphics("<path-to-image-file>")

```

````

For this code chunk, i use the label and the following options:

label
: the label that can be referenced must not include underscores but can include dashes

fig.cap
: the caption of the figure. This must be present in order to reference it.

Other options are possible:

fig.align
: i set it to have the value `center` if i want the image to reside in center

fig.fullheight
: i set it to `TRUE` if the image would be printed out smaller otherwise

out.width
: the width. Sometimes, the image is too wide for the page. Here, i set the width to be .92 of the height of the text part on the page as that image is rotated at a right angle: `.92\\textheight`

out.height
: sometimes, especially images with full size tend to be still a bit too large, so i set this parameter to have a value like `96%`

out.extra:
: for instance to turn the image with `angle` that has a value in degrees

### Referencing a figure

Referencing a figure takes place using `\@ref(fig:<label of figure>)`.

As an example, i refer to the figure \@ref(fig:workflow-example-reference-to-figure).

```{r label = "workflow-example-reference-to-figure", fig.cap = "The workflow from the written markdown to the ready output using *bookdown*."}
include_external_graphics("rmd/workflow.png")

```

### Involving an external reference in the figure caption

If i want to include an external reference inside the figure caption, i had to use the function `render_with_emojis` inside the caption:

````{verbatim label = "verbatim-workflow"}

```{r label = "workflow", fig.cap = paste("The workflow from the written markdown to the ready output using *bookdown*", render_with_emojis("((ref:riederer-21))"), ".", sep = "")}
include_external_graphics("rmd/workflow.png")

```

````

This is also obsolete because of numeric referencing.

```{r label = "workflow-example-with-external-reference", fig.cap = paste("The workflow from the written markdown to the ready output using *bookdown*", render_with_emojis("((ref:riederer-21))"), ".", sep = "")}
include_external_graphics("rmd/workflow.png")

```

Here, the function `paste` comes handy. `paste` glues strings together that can be fed into that function. The last parameter is `sep` which can be used to set the separator between the strings. Currently, i told the function to use an empty string as a separator.

### Subfigures

Sometimes, it would be wasting having each figure below each other if they are narrow. In such a case, I want the images to be side by side. For that, I need to involve *subfig* as a dependency for the print output[@riederer_66]:

```{verbatim label="example-for-subfig"}
bookdown::pdf_book:
  extra_dependencies: "subfig"

```

Pildil \@ref(fig:basics-compounds-mixture-elements) leheküljel `r render_pageref(reference="fig:basics-compounds-mixture-elements")` kujutatud konteinerid sisaldavad kas segu, ühte ühendit, ühte elementi või nende kombinatsiooni. Sinised sfäärid tähistavad ühe elemendi aatomeid, rohelised sfäärid teise elemendi aatomeid.
    
```{r label = "basics-compounds-mixture-elements", echo=TRUE, fig.cap = "Konteinerid.", fig.subcap=c("Elements, compounds, and a mixture.", "Only elements."), fig.align="center"}
include_external_graphics("rmd/alused-kordamine-ühendid-segu-element.svg")
include_external_graphics("rmd/alused-ühendid-element.svg")

```

As you see, there is no spacing between subfigures. I have not found a solution for that.

## Quick-response code[@a2024_qr]

The example (@qr-code) with the listing \@ref(lst:qr-code) on the page `r render_pageref(reference="lst:qr-code")` and the figure\@ref(fig:fig-qr-newton-iii-ekoolikott) on the page `r render_pageref(reference="fig:fig-qr-newton-iii-ekoolikott")` shows how to generate a quick-response code[@generate; @ekoolikottee].

(@qr-code)

  \begin{lstlisting}[label=lst:qr-code, language=R, caption=An example of how to generate a quick-response code.]

  librarian::shelf(c(
    "qrcode"
  ))
  code <- qr_code(x="https://e-koolikott.ee/et/oppematerjal/19850-2-1-Dunaamika/229902#229903-Newtoni-kolmas-seadus", ecl="H")
  plot(code)

  \end{lstlisting}
  
\begin{center}\faHandPointDown\end{center}

```{r label="fig-qr-newton-iii-ekoolikott", echo=FALSE, fig.cap="Newtoni kolmas seadus - viide."}
librarian::shelf(c(
  "qrcode"
))
code <- qr_code(x="https://e-koolikott.ee/et/oppematerjal/19850-2-1-Dunaamika/229902#229903-Newtoni-kolmas-seadus", ecl="H")
plot(code)

```
